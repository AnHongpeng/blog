# Vue3 散记

## （一）背景

### 市场需求与人才现状间存在不少现实矛盾

* 许多初学者通过简单的培训后便入行，但所学大多是 Demo 级别的项目知识。到了真实工作环境中往往水土不服
* 工作中只会简单地调用 API，而复杂的组件非常依赖开源的实现，如果找不到相关组件甚至难以完成开发需求；
* 没有研究过，或者根本不懂 Vue.js 底层实现原理。开发中遇到 Bug 后不懂得如何分析解决问题，也不懂如何调试；
* 工作中往往需要阅读源码去了解当前项目和一些第三方依赖库的实现方式和原理。但简单的知识填充式的培训并不能教会这些，初学者也很难自己形成这样的能力；
* 面试官考察技术背后的实现原理来判断你对技术的掌握程度、钻研精神；

了解技术实现原理是前端工作的必然要求。看源码是了解技术实现原理的最直接手法、是高效提升个人技术能力的有效途径。

### 学习源码的诸多好处

* 有助于提升你的 JavaScript 功底；
* 提升工作效率，形成学习与成长的良性循环；
* 借鉴优秀源码的经验，学习高手思路；
* 提升自己解读源码的能力

注重解读 Vue.js 在实现某个 feature 时它的设计思想是什么以及为什么会这么做。

### Vue 发展历史

Vue.js 1.x -> Vue.js 2.x，引入虚拟 DOM；

Vue2 痛点：

* 源码自身的维护性、数据量大后带来的渲染和更新的性能问题；
* 想舍弃但为了兼容一直保留的鸡肋 API；
* 更好的编程体验：更好的 TS 支持、更好的逻辑复用实践；

## （二）源码优化

* 对框架本身开发的优化，目的：让代码更易于开发和维护；
* 源码优化主要体现在：使用 monorepo 和 TypeScript 管理和开发源码。这样做的目标是提升自身代码可维护性；

### 更好的代码管理方式 monorepo

Vue.js 2.x 源码 src/ 目录：

* compiler 模板编译相关的代码
* core 与平台无关的通用运行时代码
* platforms 平台专有代码
* server 服务端渲染的相关代码
* sfc .vue 单文件解析相关代码
* shared 共享工具代码

相对于 Vue2.x 的源码组织方式，monorepo 把这些模块拆分到不同的 package 中，每个 package 有各自的 API、类型定义和测试；

这样使得模块拆分更细化，职责划分更明确，模块间的依赖关系也更加明确。开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性。

独立的 package，比如 reactivity 响应式库，是可以独立于 Vue.js 使用的。这样用户如果只想使用 Vue.js 3.0 的响应式能力，可单独依赖这个响应式库而不用去依赖整个 Vue.js。这减少了引用包的体积大小，而 Vue.js 2.x 是做不到这一点的。

### 有类型的 JavaScript：TypeScript

Vue.js 1.x 无类型语言 -> Vue.js 2.x Flow -> Vue.js 3.x TypeScript

* 在编码期间帮你做类型检查，避免一些因类型问题而导致的错误；
* 定义接口的类型，利于 IDE 对变量类型的推导；

Flow：

* Flow 是 Facebook 出品的 JavaScript 静态类型检查工具，他可以以**非常小的成本**对已有的 JavaScript 代码迁入，非常灵活，这也是 Vue.js 2.0 当初选型它时一方面的考量；
* Flow 对于一些**复杂场景类型的检查**，支持得并不好；（`const propOptions: any = vm.$options.props // wtf flow?`）

## （三）性能优化

### 源码体积优化

JavaScript 包体积越小，意味着网络传输时间越短、JS 引擎解析包的速度越快。Vue.js 3.0 中：

* 移除一些冷门的 feature；
* 引入 tree-shaking 技术；

Tree-Shaking：依赖 ES6 模块语法的静态结构（即 import 和 export），通过 **编译阶段的静态分析**，找到没有引入的模块并打上标记。

如果你在项目中没有引入 Transition、KeepAlive 等组件，那么它们对应的代码就不会打包，这样也就间接达到了减少项目引入 Vue.js 包体积的目的。

### 数据劫持优化

实现 DOM 功能，必须劫持数据的访问和更新：

当数据改变后，为了自动更新 DOM，那么就必须劫持数据的更新。也就是说当数据发生改变后能自动执行一些代码去更新 DOM。

Vue.js 怎么知道更新哪一片 DOM？

因为 **在渲染 DOM 的时候访问了数据**，我们可以对它进行访问劫持。这样就在内部建立了依赖关系，也就知道数据对应的 DOM 是什么了。

#### Vue.js 1.x 和 2.x 通过 Object.defineProperty

Vue.js 1.x 和 2.x 通过 `Object.defineProperty` 这个 API 劫持数据的 `getter` 和 `setter`：

``` js
Object.defineProperty(data, 'a', {
  get() {
    // track
  },
  set() {
    // trigger
  }
})
```

缺陷1：必须预先知道要拦截的 `key` 是什么，并不能检测对象属性的添加和删除。

缺陷2：对于嵌套层级较深的对象，如果要劫持内部深层的变化，就需要递归遍历，把每一层对象属性都变成响应式的。那么如果我们定义的响应式数据比较复杂，就会带来相当大的性能负担。

``` js
export default {
  data: {
    a: {
      b: {
        c: {
          d: 1
        }
      }
    }
  }
}
```

#### Vue.js 3.0 使用 Proxy API

Vue.js 3.0 使用 Proxy API 做数据劫持：

``` js
observed = new Proxy(data, {
  get() {
    // track
  },
  set() {
    // trigger
  }
})
```

由于它劫持的是整个对象，自然对对象属性的增加和删除都能检测到。

注意：Proxy API 并不能监听到内部深层次的对象变化。因此 Vue.js 3.0 的处理方式是 **在 getter 中去递归响应式**。**这样的好处**是真正访问到的内部对象才会变成响应式，而不是无脑递归。这样无疑也在很大程度上提升了性能。

## （四）编译优化

除了数据劫持部分的优化，我们可以在耗时相对较多的 patch 阶段想办法。

Vue.js 3.0 通过在编译阶段优化编译的结果，实现运行时 patch 过程的优化。

Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，但是在单个组件内部，必须要遍历整个 vnode 树，导致 vnode 性能和模板大小正相关（跟动态节点的数量无关）。

Vue.js 3.0 做到了，它通过编译阶段对静态模板的分析，编译生成了 Block tree。

### Block tree

* Block tree 是一个将模板**基于动态节点**指令切割的嵌套区块，每个区块内部的节点结构是固定的。每个区块只需要以一个 Array 来追踪自身包含的动态节点
* 借助 Block tree，Vue.js 将 vnode 更新性能由与模板整体大小相关提升为 **与动态内容的数量相关**。

### 其他编译优化

* 对 Slot 的编译优化；
* 事件侦听函数的缓存优化；
* 在运行时重写了 diff 算法；

## （五）语法 API 优化

提供 Composition API。

### 优化逻辑组织

在 Vue.js 1.x 和 2.x 中，编写组件本质就是在编写一个”包含了描述组件选项的对象“，我们把它称为 **Options API**。

Options API：

* Options API 的设计是按照 `methods`、`computed`、`data`、`props` 这些不同的选项分类
* **当组件小的时候**，这种分类方式一目了然；但是在大型组件中，一个组件可能有多个逻辑关注点。当使用 Options API 时，每个关注点都有自己的 Options。如果需要修改一个逻辑关注点，就需要在单个文件中不断上下切和寻找。

Composition API：

将某个逻辑关注点的相关代码全都放在一个函数里。这样当需要修改一个功能时，就不再需要在文件中跳来跳去。

### 优化逻辑复用

Vue.js 2.x 中通常使用 mixins 来复用逻辑。当组件中有大量不同 mixins 时，会存在 2 个非常大的问题：

* 命名冲突；
* 数据来源不清晰；

这是因为：

* 首先，每个 mixin 都可以定义自己的 props、data，它们之间是无感的。所以很容易定义相同的变量，导致命名冲突；
* 另外，对于组件而言，**如果模板中使用不在当前组件中定义的变量**，那么就会不太容易知道这些变量在哪里定义的，这就是数据来源不清晰；

Composition API 很好地解决了 mixins 这 2 个问题。

使用 Composition API 同时也有更好的**类型支持**：因为它们都是一些函数，在调用函数时，自然所有的类型都被推导出来了（不像 Options API 所有的东西使用 this）

另外，Composition API 对 tree-shaking 友好，代码也更容易压缩。

## （六）引入 RFC：使每个版本改动可控

RFC：Request For Comments。旨在为新功能进入框架提供一个一致且受控的路径。

通过 RFC 了解每一个 feature 采用或被废弃掉的前因后果。

## （七）其他

### 小程序跨端方案

* uni-app
* Mpx
* chameleon
* WePY
