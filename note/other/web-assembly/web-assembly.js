# WebAssembly 调研

## 调研结论

结论：现阶段深入研究的价值非常小，社区还处于初期阶段，市场应用场景非常有限。

论点：

* 技术栈与前端无关：官方主推用 C/C++，编译工具链是 C++ 系语言交叉编译 Emscripten 一套，仅仅是最终编译结果是 JS。即便深入去学、去用，学习知识点也在非前端领域；
* 性能方面没有压倒性优势：WebAssembly 对比现代浏览器引擎使用的 JIT 技术，性能优化方面并不是上升了一个台阶。况且 90% 的 Web 应用是 IO 密集并非计算密集型，它的性能优化场景十分有限。因此它的定位是对 JS 的补充，而非取代 JS；
* 市场需求量很小，中短期内需求还是集中在已有的原生应用的跨平台迁移上。小厂是不会既有 C 又有前端团队还要实现 C 的应用跨平台的；

建议：判断它目前的程度都还不到专门开一节公开课，能展示的很有限：

1.展示程序得非前端，才能突显跨平台的强大，但整几段 C 代码，没人愿意深入看；
2.需要用前端人没听过、不想学的编译工具链，一通操作后得到熟悉的 JS；
3.结果性能方面的提升还不好演示，又要用到性能分析对比工具；
4.市场应用场景少的可怜。小厂不会用，大厂在用它做性能优化；

判断它充其量能算“Web 跨平台领域”中的一个小分支，如果有一节专门讲 Web 跨平台的公开课，倒是可以提及一下，但也就处于简单提及的水平。

建议对 WebAssembly 持低频率的中长期关注即可。

> 以下是对 WebAssembly 的详细介绍，内容来源于线上资源及自己的的理解。

## 什么是 WebAssembly

2019 年 12 月，万维网联盟（W3C）宣布 WebAssembly 核心规范正式成为 Web 标准。WASM 是一整套字节码标准（和以后的接口标准），它是个编译后产物而不是编译前的语言。

WebAssembly 源于 Mozilla 发起的 Asm.js 项目，设计补充而非取代 JavaScript，它是一个二进制格式，容易翻译到原生代码，本地解码速度比 JS 解析更快，让高性能的 Web 应用在浏览器上运行成为可能，比如视频游戏、计算机辅助设计、视频和图像编辑、科学可视化等等。

它作为一个安全的、可移植的、高效率的虚拟机沙箱，可以跨平台（不同操作系统、不同 CPU 体系架构下）安全运行，目前 WASM 1.0（MVP 版）已得到所有主流浏览器厂商的广泛支持：Google Chrome、Microsoft Edge、Apple Safari、Mozilla FireFox 等。

在浏览器外：由 Mozilla、fastly、inter、Red hat 组成了字节码联盟，该联盟旨在通过协作实施标准和提出新标准，以完善 WebAssembly 在浏览器之外的生态。

WebAssembly 的设计初衷之一是为了解决 JavaScript 的性能问题，使得 Web 网页应用有接近本机原生应用的性能。作为一个通用、开放、高效的底层虚拟机抽象，众多编程语言（如 C/C++, Rust 等）可以将现有应用编译成为 WASM 的目标代码，运行在浏览器中。这让应用的开发技术与运行时技术解耦，极大促进了代码复用。

![WebAssembly 工作流程](https://pic3.zhimg.com/80/v2-dca883d8c56810476f4a0c57d0744252_1440w.jpg)

## 开发语言支持

目前支持众多高级语言的编译：.Net、C、C#、C++、Go、Java、JavaScript、PHP、Python、Ruby、Rust、Swift、TypeScript 等等。具体的语言支持，参阅 [Awesome WebAssembly Languages](https://github.com/appcypher/awesome-wasm-langs#dotnet)

* 理论上所有基于 LLVM 架构的高级语言都可以编译到 WASM，只不过一些扩展语言会附带一个巨大的 runtime；
* 官方主推 C/C++ 作为官方开发语言；
* 前端则推荐 [AssemblyScript，开发语言是基于 TypeScript，是前端开发的最佳选择。

## 现阶段发展情况

目前为止，WebAssembly 技术仍处于初期阶段，WASI 也有很多局限性。但是社区的进展非常快，SIMD 指令支持，多线程处理等规范也正在快速演进中。WebAssembly 已经打破次元壁，将高性能的计算能力带领到 Web 浏览器端，越来越多的计算密集型的游戏、AI 模型预测、和数据处理应用被移植到浏览器端，可以为应用提供更加优化的用户体验。

WebAssembly 更广阔的空间在云计算领域、区块链等分布式计算领域。WebAssembly 轻量、敏捷、安全的特性，可以有效降低 Serverless 应用启动速度和资源消耗。同时 WebAssembly 的可移植，可以让应用一致运行在从云端服务器到边缘 IoT 设备等不同平台环境中，让计算无处不在。

## 应用场景

* 它代表了一种跨平台的全新方向，对原生应用开发者来说具备巨大商业价值。可以将已成熟的原生代码跨平台到 Web 浏览器运行；
* 未来的 AI、游戏、视频处理等；
* 分布式计算；

## 理性对待

### 性能

WASM 里的 Assembly 并不意味着真正的汇编码，而只是种新约定的字节码，也是需要解释器运行的。这种解释器肯定比 JS 解释器快得多，但自然也达不到真正的原生机器码水平。

Google Chrome V8 中引入了 JIT（Just-In-Time） 技术来提高 JS 执行效率，一个可供参考的数据指标是：JS 上了 JIT 后整体性能大致是机器码 1/20 的水平，而 WASM 则可以跑到机器码 1/3 的量级（视场景不同很不好说，仅供参考）。**相当于即便你写的是 C++ 和 Rust 级的语言，得到的其实也只是 Java 和 C# 级的性能。**
这也可以解释为什么 WASM 并不能在所有应用场景都显示出压倒性的性能优势：**只要你懂得如何让 JS 引擎走在 Happy Path 上，那么在浏览器里，JS 就敢和 Rust 五五开。**

因此，单纯地引入用 C 编译出来的 WASM，并不一定能显著提升性能，因为现代浏览器标配的 JIT 技术很可能能达到相似水平。

### 前端框架不会用 WASM 重写

这件事的投入产出比很低，对于主流的前端应用来说，它们都是 IO 密集而不是计算密集型的，这时 WASM 增加的算力很难成为瓶颈的突破点，反而会增加许多工程上的维护成本。用 WASM 重写主流 UI 框架，意味着前端需要重度依赖一门完全不同的语言技术栈。

### WASM 并不属于前端生态

**一个 WASM 应用，其编译工具链和依赖库生态，基本完全不涉及 JS**。依赖 Emscripten 等编译器将 C++/Golang/Rust/Kotlin 等强类型语言编译成为 WebAssembly 字节码（.wasm 文件）。所以 WebAssembly 并不是 Assembly（汇编），它只是看起来像汇编而已。而 JS 就像机器码那样，只是工具链编译出来的输出格式而已。

## 参考线上资源

* [WebAssembly 初探](https://zhuanlan.zhihu.com/p/114542645)
* [一个白学家眼里的 WebAssembly](https://zhuanlan.zhihu.com/p/102692865)
* [恕我直言，90% 的应用场景都不需要用WebAssembly！](https://zhuanlan.zhihu.com/p/79792515)
* [有哪些效果拔群的 WebAssembly 应用？](https://www.zhihu.com/question/265700379/answer/956235550)
* [如何评论浏览器最新的 WebAssembly 字节码技术？](https://www.zhihu.com/question/31415286/answer/58022648)
* [“网红” WebAssembly 与 K8s 如何实现双剑合璧？](https://zhuanlan.zhihu.com/p/112387861)
