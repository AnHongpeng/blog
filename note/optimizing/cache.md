# 缓存

> 本文笔记摘自 [一文读懂前端缓存 | 知乎](https://zhuanlan.zhihu.com/p/44789005)

cache 的发音是 `[kæʃ]`（同 cash）。

## 前端缓存 VS 后端缓存

![请求的3个步骤](https://pic3.zhimg.com/80/v2-05f4e6a5aaac9fce4d2a7a2fcc652c9e_1440w.jpg)

基本的网络请求就是3个步骤：请求、处理、响应

* 后端缓存：主要集中在“处理”步骤，通过「保留数据库连接」、「存储处理结果」等方式缩短处理时间，尽快进入“响应”步骤
* 前端缓存：
  * 在“请求”步骤中，浏览器可以通过存储结果的方式直接使用资源，从而省去了发送请求；
  * 在“响应”步骤中，需要浏览器和服务器共同配合，通过减少响应内容来缩短传输时间

## 按缓存所处的位置分类

### memory cache

memory cache 是「内存中的缓存」，与之相对的是 disk cache，也就是硬盘中的缓存。按操作系统的常理：先读内存，再读硬盘。

几乎所有的网络请求资源都会被浏览器自动加入到 memory cache 中，但由于这些资源数量很大，并且浏览器内存也是有限的，所以 memory cache 注定只是一个「短期存储」。常规情况下，浏览器标签页关闭后，该次浏览的 memory cache 便会失效。

### disk cache

disk cache 也叫 HTTP cache，顾名思义是「存储在硬盘上的缓存」，因此它是持久存储的，是实际存在于文件系统中的。

disk cache 会严格根据 HTTP 头信息中的各类字段来判断要缓存哪些资源。

当命中缓存后，浏览器会从硬盘中读取资源，虽然比起从内存中读取慢了一些，但比网络请求还是快了很多。

凡是持久性存储都会面临容量增长的问题，disk cache 也不例外。在浏览器自动清理时，会按算法把“最老的”或者“最可能过时的”资源删除，不同浏览器算法的实现是不同的。

### Service Worker

memory cache 和 disk cache 的缓存策略以及缓存/读取/失效的动作都是由浏览器内部判断进行的。我们只能设置响应头的的某些字段来告诉浏览器，而不能自己操作。

举个生活中去银行存/取钱的例子来说，你只能告诉银行职员，我要存/取多少钱，然后把由他们经过一系列的记录和手续之后，把钱放到金库中去，或者从金库中取出钱来交给你。

但 Service Worker 的出现，给予了我们另外一种更加灵活，更加直接的操作方式。我们可以绕开银行职员，自己走到金库前（当然是有别于上述金库的一个单独的小金库），自己把钱放进去或取出来。因此我们可以选择放哪些钱（缓存哪些文件），什么情况把钱取出来（路由匹配规则），取哪些钱出来（缓存匹配并返回）。

我们可以在 Chrome 浏览器控制台中，Application --> Cache Storage 找到这个单独的“小金库”。这个缓存是永久性的，即便关闭标签页或者浏览器，下次打开依然还在。

有 2 种情况会将缓存中的资源清除：

* 手动调用 API `cache.delete(resource)`
* 缓存容量超过限制，被浏览器清空

综上，请求时从缓存获取资源的优先级是：

1. Service Worker
2. Memory Cache
3. Disk Cache
4. 网络请求

由上到下寻找，找到即返回，找不到则继续。
